##### 正则表达式

> 正则表达式学习资源：https://r2coding.com/#/README?id=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F

> 正则表达式用于定义一些字符串的规则
>
> ​		计算机可以根据正则表达式来检查一个字符串是否符合规则
>
> ​		将字符串中符合规则的内容提取出来

正则表达式都能帮我们做什么？

​	1、数据隐藏（188****3456）

​	2、数据采集

​	3、数据过滤

​	4、数据验证（手机号，邮箱地址）

###### 创建正则表达式

**使用构造函数来创建正则表达式**

语法：

​	var 变量 = new RegExp("正则表达式",匹配模式");

​	使用typeof检查正则对象，会返回Object

​	在构造函数中可以传递一个`匹配模式`作为第二个参数

​			可以是：

​				i 忽略大小写

​				g 全局匹配模式， 会进行多次匹配

```
	//这个正则表达式可以来检查一个字符串中是否含有"a",并且忽略大小写
	var reg = new RegExp("a",'i')
	//这个正则表达式可以来检查一个字符串中是否含有"ab",并且忽略大小写
	var reg = new RegExp("ab",'i')
```

**使用字面量来创建正则表达式**

​		语法：var 变量 = /正则表达式/匹配模式

```
	var reg = new RegExp('a','i')
	var reg2 = /a/i; //等同于上面的创建方式
	console.log(reg2.test('a666'))  //true
```

`注：`

​	使用字面量的方式创建更加简单

​	使用构造函数创建更加灵活

###### 正则语法

​		1、**检查一个字符串是否含有“a"**

```
		//二者等价
		var reg = new RegExp('a') 
		var reg2 = /a/
```

​		2、**检查一个字符串中是否含有a或b**

```
		var reg = /a|b/    //使用 | 表示或者的意思
```

​		3、**检查一个字符串中是否含有字母**	

```
		var reg = /[ab]/   //[ ]里的内容也是或的关系，[ab] == a|b
		var reg2 = /[a-z]/  //[a-z] 任意小写字母
		var reg3 = /[A-Z]   //[A-Z] 任意大写字母
		var reg4 = /[A-z]/  //[A-z] 任意字母
		var reg5 = /[0-9]/  //[0-9] 任意数字
		console.log(reg.test("ae"))  //true
```

​		4、**检查一个字符串中是否含有abc或adc或aec**		

```
		var reg = /abc|adc|aec/
		var reg2 = /a[bde]c/   //二者等价
		console.log(reg2.test("aec"))  //true
		console.log(reg2.test("aeec"))  //false
```

​		5、**[^]除了**			

```
		var reg = /[^ab]/  //字符串除了"ab"都行
		var reg2 = /[^0-9]/  //字符串除了纯数字字符串
		console.log(reg.test("ab"))  //false
		console.log(reg.test("abc"))  //true
		console.log(reg2.test("abc"))  //true
		console.log(reg2.test("abc1"))  //false
```

​		6、**^检查一个字符串中是否以a开头**

​					^表示开头

```
		let reg = /^a/
		console.log(reg.test('fdsdfsfda')) //false
		console.log(reg.test('a45454sdhsadh'))  //true
```

​		7、**$ 检查一个字符串中是否以a结尾**

​					$表示结尾

```
		let reg = /a$/
		console.log(reg.test('fdsdfsfda')) //true
		console.log(reg.test('a45454sdhsadh'))  //false
		let reg2 = /^a$/
    		console.log(reg2.test('a')); //true
    		console.log(reg2.test('a4a')); //false
    		let reg = /^a|a$/   //a开头或者a结尾
    		console.log(reg.test('a322323'));  //true
```

​	8、**/^$/ 完全匹配正则表达式，而不是含有就行了**

```
		 let reg = /^a$/
           console.log(reg.test("a")) //true
           console.log(reg.test("aa")) //false
           let reg2 = /^aa$/
           console.log(reg2.test("a")) //false
           console.log(reg2.test("aa")) //true
           let reg3 = /^a123a$/
           console.log(reg3.test("a123a")); //true
```

​	9、**创建一个正则表达式，用来检查一个字符串是否是一个合法手机号**

​				手机号的规则（11位）：

​					1、以1开头

​					2、第二位3-9任意数字

​					3、第三位以后任意数字9个

​					^1  [3-9]  [0-9]{9}$

```
		var phoneStr = "17806707109"
         let reg = /^1[3-9][0-9]{9}$/  //如果以^开头$结尾，那么必须字段必须按规则严格匹配，不是含有就行了，{9}的意思是限定前面的[0-9]的数量
         console.log(reg.test(phoneStr)); //true
         console.log(reg.test(110));  //false
```

10、**检查一个字符串中是否含有 .**

​		. 表示任意字符

​		在正则表达式中使用\作为转义字符

​		\\.表示.

​		\\\\表示\

```
		var reg = /\./
		reg = /\\/
		console.log(reg.test("b.\\"))   //true
```

​		注意：使用构造函数时，由于它的参数是一个字符串，而\是字符串中的转义字符

​				 如果要使用\则需要使用\\\\来替代

11、**创建一个正则表达式检查一个字符串中是否含有单词child**		

```
	    let reg = /\bchild\b/
	    console.log(reg.test("hello child ren")) //true
	    console.log(reg.test("hello children")) //false
```

12、**去除掉字符串中前后的空格**

​				`去掉空格就是使用""来替换空格`

```
	    let str = prompt("请输入：")
         str = str.replace(/^\s*|\s*$/g,"")  
         console.log(str);
```

13、**检查邮件地址格式的正则表达式**

​		2249096563@qq.com

​		任意字母数字下划线  @  任意字母数字  .任意字母（2-5位）  任意字母（2-5位）

​		\w{3,}                     @  [A-z0-9]+      (\\.）[A-z]{2,5}){1,2}

```
	   let str = prompt("请输入：")
    	   var emailReg = /^\w{3,}@[A-z0-9]+(\.[A-z]{2,5}){1,2}$/
    	   console.log(emailReg.test(str));
```

 14、**排除含有lottery的行**

​		 //不含有he

​    	 let reg = /^((?!he).)*$/

​		正则：/^(http)(.(?!lottery))*(html)$/

​		效果：

​		<img src="https://webpon-img.oss-cn-guangzhou.aliyuncs.com/img/20210505215706.png" alt="image-20201229153839358" style="zoom:80%;" />

贪婪模式会尽可能匹配长

![image-20201229111303212](https://webpon-img.oss-cn-guangzhou.aliyuncs.com/img/20210505215710.png)

非贪婪模式不会，在*或者+后面加一个？就会变成非贪婪模式了

**15、查询重复的字符**

```
let reg = /(\w)\1*/g
```

**正则表达式中的小括号"()"。是代表分组的意思。 如果再其后面出现\1则是代表与第一个小括号中要匹配的内容相同。**

**注意：\1必须与小括号配合使用**

**16、不包含某些字符串**

```
^((?!hede).)*$
```

表达式`(?!hede).`会往前查找，看看前面是不是没有`hede`字串，如果没有(是其它字符)，那么`.`(点号)就会匹配这些其它字符。这种正则表达式的“查找”也叫做 “zero-width-assertions”(零宽度断言)，因为它不会捕获任何的字符，只是判断。

在上面的例子里，每个空字符都会检查其前面的字符串是否不是‘hede’，如果不是，这`.`(点号)就是匹配捕捉这个字符。表达式`(?!hede).`只执行一次，所以，我们将这个表达式用括号包裹成组`(group)`，然后用`*`(星号)修饰——匹配0次或多次：

**量词**

​		-通过量词可以设置一个内容连续出现的次数

​		-量词只对它前面的一个内容起作用

​		-{n} 正好出现n次

​		-{m,n}出现m——n次

​		-{m,} 出现m次及以上

​       - + 至少一个，相当于{1，}

​		- * 0个或多个，相当于{0，}

​		- ？0个或1个，相当于{0，1}

```
          var reg = /a{3}/
          //ababab
          reg2 = /(ab){3}/
          reg3 = /ab{1,3}c/
          reg4 = /ab+c/
          reg5 = /ab*c/
          console.log(reg.test("aaabb"))  //true
          console.log(reg2.test("ababab"))  //true
          console.log(reg3.test("abc"))  //true
          console.log(reg3.test("abbbbc"))  //false
```

![image-20201228215248352](https://webpon-img.oss-cn-guangzhou.aliyuncs.com/img/20210505215720.png)

###### 正则表达式的组匹配

**什么是分组**

通俗来说，我理解的分组就是在正则表达式中用（）包起来的内容代表了一个分组，像这样的：

```
     var reg = /(\d{2})/
     reg.test('12');  //true
```

这里reg中的(/d{2})就表示一个分组，匹配两位数字

**分组内容的的形式**

一个分组中可以像上面这样有一个具体的表达式，这样可以优雅地表达一个重复的字符串

```
     /hahaha/
     /(ha){3}/
```

这两个表达式是等效的，但有了分组之后可以更加简洁。

分组中还可以有多个候选表达式，例如

```
     var reg = /I come from (hunan|hubei|zhejiang)/;
     reg.test('I come from hunan');   //true
     reg.test('I come from hubei');   //true
```

也就是说在这个分组中，通过|隔开的几个候选表达式是并列的关系，所以可以把这个|理解为或的意思

**分组的分类**

分组有四种类型

- 捕获型 ()
- 非捕获型 (?:)
- 正向前瞻型 (?=)
- 反向前瞻型 (?!)
  我们使用的比较多的都是捕获型分组，只有这种分组才会暂存匹配到的串

**分组的应用**

分组在正则中还算使用的比较广泛的，我们常用的是捕获型分组

- 捕获与引用

  - 被正则表达式捕获(匹配)到的字符串会被暂存起来，其中，由分组捕获到的字符串会从1开始编号，于是我们可以引用这些字符串：

  ```
      var reg = /(\d{4})-(\d{2})-(\d{2})/;
      var dateStr = '2018-04-18';
      reg.test(dateStr);  //true
      console.log(RegExp.$1);  //2018
      console.log(RegExp.$2);   //04
      console.log(RegExp.$3);   //18
  ```

  如果碰到类似/((kid) is (a (doubi)))/的嵌套分组，捕获的顺序是什么？来试试：

  ```
    var reg = /((kid) is (a (doubi)))/  
    var str = "kid is a doubi"    
    reg.test( str ) // true    
    RegExp.$1 // kid is a doubi  
    RegExp.$2 // kid  
    RegExp.$3 // a doubi  
    RegExp.$4 // doubi    
  ```

  规则是以左括号出现的顺序进行捕获。

- 结合`replace方法`做字符串自定义替换

  - String.prototype.replace方法的传参中可以直接引用被捕获的串，比如我们想开发中常见的日期格式替换,例如后台给你返回了一个2018/04/18,让你用正则替换为2018-04-18，就可以利用分组

  ```
  var dateStr = '2018/04/18';
  var reg = /(\d{4})\/(\d{2})\/(\d{2})/;
  dateStr = dateStr.replace(reg, '$1-$2-$3') //"2018-04-18"
  ```

  不过这里需要注意的是/是需要用\转义的

  如果第二差数是以回调函数的形式的话，回调函数的第一个参数是`每次`匹配到的全部字符串

  ```
      function toCamelCase(str) {
              return str.replace(/-(.)/g, function (match, $1) {
                console.log(match,$1);    //-d d
                return $1.toUpperCase()
              })
            } 
          console.log(toCamelCase("abc-def-gh"));   //abcDefGh
  ```

- 反向引用

  - 正则表达式里也能进行引用，这称为反向引用：

  ```
       var reg = /(\w{3}) is \1/
       reg.test('kid is kid') // true
       reg.test('dik is dik') // true
       reg.test('kid is dik') // false
       reg.test('dik is kid') // false
  ```

  - 需要注意的是，如果引用了越界或者不存在的编号的话，就被被解析为普通的表达式

  ```
       var reg = /(\w{3}) is \6/;
       reg.test( 'kid is kid' ); // false
       reg.test( 'kid is \6' );  // true
  ```

- 非捕获型分组

  - 有的时候只是为了分组并不需要捕获的情况下就可以使用非捕获型分组，例如

  ```
       var reg = /(?:\d{4})-(\d{2})-(\d{2})/
       var date = '2012-12-21'
       reg.test(date)
       RegExp.$1 // 12
       RegExp.$2 // 21
  ```

- 正向与反向前瞻型分组

  - 正向前瞻型分组：你站在原地往前看，如果前方是指定的东西就返回true，否则为false

  ```
       var reg = /kid is a (?=doubi)/
       reg.test('kid is a doubi') // true
       reg.test('kid is a shabi') // false
  ```

  - 反向前瞻型分组：你站在原地往前看，如果前方不是指定的东西则返回true，如果是则返回false

  ```
       var reg = /kid is a (?!doubi)/
       reg.test('kid is a doubi') // false
       reg.test('kid is a shabi') // true
  ```

- 既然前瞻型分组和非捕获型分组都不会捕获，那他们有什么区别呢？先看例子：

```
     var reg, str = "kid is a doubi";
     reg = /(kid is a (?:doubi))/
     reg.test(str)
     RegExp.$1 // kid is a doubi

     reg = /(kid is a (?=doubi))/
     reg.test(str)
     RegExp.$1 // kis is a
```

也就是说非捕获型分组匹配到的字符串任然会被外层分组匹配到，而前瞻型不会，所以如果你希望在外层分组中不匹配里面分组的值的话就可以使用前瞻型分组了。

###### 正则表达式对象的方法

正则表达式的方法：

​		test()

​			-使用这个方法可以用来检查一个字符串是否符合正则表达式的规则，

​			 如果符合则返回true,否则返回false

```
		var reg = new RegExp("a",'i')
		console.log(reg.test("abcdjsk"))  //true
		console.log(reg.test("bcdjsk"))   //false	
```

​		exec()

​			-返回字符串中指定模式的字串，一次只能获取一个与之匹配的结果

```
		var reg = /[a-z]{3}/
		console.log(reg.exec("abcdjsk"))  //abc
		console.log(reg.exec("ab"))  //null
```



###### 支持正则表达式的String对象的方法

**search()**

​	**-可以搜索字符串中是否含有指定内容**

​	**-如果搜索到指定内容，则会返回第一次出现的索引，如果没有搜索到则返回 -1**

​	**-它可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串，并返回检索到的字符下标**

​	**-search()只会查找第一个，即使设置全局匹配也没用**

```
	var str "hello abc hello aec"
	//搜索字符串中是否含有abc或aec或afc
	var result = str.search(/a[bef]c/)
	console.log(result)  //6
```

**match()**

​	**-可以根据正则表达式，从一个字符串中将符合条件的内容提取出来**

​	**-默认情况下我们的match方法只会找到第一个符合要求的内容，找到之后就停止检索了**

​			**我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容**

​			返回值以数组的形式返回

​			可以为一个正则表达式设置多个匹配模式，且顺序无所谓

​	-match()会将匹配到的内容封装到一个数组中返回，即时只查询到一个结果

```
	let str = "1a2b3cA"
	let result = str.match(/[a-z]/gi)  //全局匹配且忽略大小写
	console.log(result) //a,b,c,A
```

**replace()**

​	-可以将字符串中指定内容替换为新的内容

​	-参数：

​			1、被替换的内容,可以接收一个正则表达式作为参数

​			2、新的内容

返回值是改变后的数组

```
	let str = "78a898a98"
	let result = str.replace("a","@_@")
	console.log(result)  //78@_@898a98
	let result2 = str.replace(/a/g,"@_@")
	console.log(result2)  //78@_@898@_@98
	let result3 = str.replace(/a/g,"")
	console.log(result3)  //7889898
```

**split()**

​	**-可以将一个字符串拆分为一个数组**

​	**-方法中可以传递字符串或者一个正则表达式作为参数，如果参数是正则表达式，那么方法就会根据正则表达式来拆分字符串**

​	**-这个方法即使不指定全局匹配，也会全局拆分**

返回值是拆分后的数组

```
	var str = "1a2b3c4"
	//根据任意字母来将字符串进行拆分
	var result = str.split(/[A-z]/)
	console.log(result) //1,2,3,4
```

###### 常用的正常表达式

​	一、校验数字的表达式

1. 数字：^[0-9]*$

2. n位的数字：^\d{n}$

3. 至少n位的数字：^\d{n,}$

4. m-n位的数字：^\d{m,n}$

5. 零和非零开头的数字：^(0|[1-9][0-9]*)$

6. 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$

7. 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$

8. 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$

9. 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$

10. 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$

11. 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$

12. 非零的负整数：^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$

13. 非负整数：^\d+$ 或 ^[1-9]\d*|0$

14. 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$

15. 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$

16. 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$

17. 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$

18. 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$

19. 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$



二、校验字符的表达式

1. 汉字：^[\u4e00-\u9fa5]{0,}$

2. 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$

3. 长度为3-20的所有字符：^.{3,20}$

4. 由26个英文字母组成的字符串：^[A-Za-z]+$

5. 由26个大写英文字母组成的字符串：^[A-Z]+$

6. 由26个小写英文字母组成的字符串：^[a-z]+$

7. 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$

8. 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$

9. 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$

10. 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$

11. 可以输入含有^%&',;=?$\"等字符：[^%&',;=?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+

 

 

三、特殊需求表达式

1. Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$

2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.?

3. InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$

4. 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$

5. 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$

6. 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7}

7. 身份证号(15位、18位数字)：^\d{15}|\d{18}$

8. 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$

9. 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$

10. 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$

11. 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$

12. 日期格式：^\d{4}-\d{1,2}-\d{1,2}

13. 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$

14. 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$

15. 钱的输入格式：

16. 1.有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：^[1-9][0-9]*$

17. 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$

18. 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$

19. 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$

20. 5.必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：^[0-9]+(.[0-9]{2})?$

21. 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$

22. 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$

23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$

24. 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里

25. xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$

26. 中文字符的正则表达式：[\u4e00-\u9fa5]

27. 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))

28. 空白行的正则表达式：\n\s*\r (可以用来删除空白行)

29. HTML标记的正则表达式：<(\S*?)[^>]*>.*?</\1>|<.*? /> (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)

30. 首尾空白字符的正则表达式：^\s*|\s*$或(^\s*)|(\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)

31. 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始)

32. 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字)

33. IP地址：\d+\.\d+\.\d+\.\d+ (提取IP地址时有用)

34. IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))
