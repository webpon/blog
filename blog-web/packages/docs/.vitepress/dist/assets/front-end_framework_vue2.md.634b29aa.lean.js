import{_ as i,c as C,d as n,e as s,b as a,t as o,n as A,g as y,f as D,a as l,r as t,o as d}from"./app.40dc24c8.js";const S=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"front-end/framework/vue2.md"}'),u={name:"front-end/framework/vue2.md"},g=l("",114),m=n("table",null,null,-1),h=l("",76),F=l("",147),v=l("",130),b=n("code",null,"具名插槽可以和匿名插槽混用",-1),f=l("",176),q=l("",102),k=n("p",null,[n("img",{src:"https://webpon-img.oss-cn-guangzhou.aliyuncs.com/img20210505220648-1657022362077254.png",alt:"b"})],-1),w=n("p",null,"这时候的push和replace实际就是history的pushState和replaceState方法",-1),x=n("code",null,"<router-view>",-1),E=l("",429);function V(e,_,j,z,M,$){const c=t("Filters"),r=t("child2"),p=t("router-view");return d(),C("div",null,[g,n("p",null,[s("Vue.components中的Filters是真正使用的插件名，比如"),a(c),s(",而不是"),m]),h,n("p",null,"给img标签的src属性赋值时，按照传统的方法"+o(e.url)+"：",1),F,a(r,A(y(e.$attrs)),null,16),s("，这是v-bind唯一可以直接跟等号的特殊写法):"),v,n("p",null,[b,s("，具名插槽有名字，子组件通过 "),D(e.$slots,"up"),s('定义，父组件在使用的时候通过slot="up"使用，并且会放到对应的位置')]),f,n("p",null,"在上例的基础上，我们把 computed 区块中的 totalMarks 函数整体移到 methods 中。同时在模板中将 "+o("totalMarks")+" 替换成 "+o("totalMarks()")+" 你最终看到的结果是一样的，如下所示：",1),q,n("p",null,[s("当然要渲染在哪里，需要一个标签"),a(p)]),n("p",null,[s("还可以用<keep-alive>包裹"),a(p),s("来保持状态，防止被销毁,使用keep-alive的保持的组件都要有name属性")]),k,w,n("p",null,[s("一级路由会在任何的"),a(p),s("中渲染对应的模板，App.vue中的 "),x,s(" 是最顶层的出口，渲染最高级路由匹配到的组件。子路由只会在父路由的"),a(p),s("中的模板的"),a(p),s("渲染")]),E])}const B=i(u,[["render",V]]);export{S as __pageData,B as default};
